<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ttf2stitch — Font Inspector</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: system-ui, -apple-system, sans-serif;
    background: #faf6f1;
    color: #5a4a3a;
    display: flex;
    height: 100vh;
    overflow: hidden;
  }

  /* ── Sidebar ── */
  .sidebar {
    width: 300px; min-width: 300px;
    background: #ffffff;
    border-right: 2px solid #e8d5c4;
    display: flex; flex-direction: column;
    overflow: hidden;
  }
  .sidebar-header {
    padding: 16px;
    border-bottom: 1px solid #e8d5c4;
    background: #faf6f1;
    cursor: pointer;
  }
  .sidebar-header h1 { font-size: 18px; font-weight: 700; display: flex; align-items: center; gap: 8px; }
  .sidebar-header h1 .accent { color: #e85d75; }
  .sidebar-header p { font-size: 12px; color: #8a7a6a; margin-top: 2px; }

  .filter-bar {
    padding: 10px 16px;
    border-bottom: 1px solid #e8d5c4;
    display: flex; gap: 6px; flex-wrap: wrap;
    background: #faf6f1;
  }
  .filter-btn {
    padding: 4px 12px; border: 1px solid #e8d5c4; background: #ffffff;
    color: #8a7a6a; border-radius: 20px; font-size: 11px; font-weight: 500;
    cursor: pointer; transition: all 0.2s; font-family: inherit;
  }
  .filter-btn:hover { border-color: #e85d75; color: #e85d75; }
  .filter-btn.active {
    background: linear-gradient(135deg, #e85d75, #d64560);
    border-color: #e85d75; color: #fff;
    box-shadow: 0 2px 8px rgba(232,93,117,0.3);
  }

  .search-bar { padding: 8px 16px; border-bottom: 1px solid #e8d5c4; }
  .search-input {
    width: 100%; padding: 7px 12px; border: 1px solid #e8d5c4; border-radius: 8px;
    font-size: 13px; font-family: inherit; color: #5a4a3a; background: #faf6f1; outline: none;
  }
  .search-input:focus { border-color: #e85d75; box-shadow: 0 0 0 3px rgba(232,93,117,0.12); }

  .font-list { flex: 1; overflow-y: auto; padding: 8px; }
  .font-list::-webkit-scrollbar { width: 6px; }
  .font-list::-webkit-scrollbar-thumb { background: #e8d5c4; border-radius: 3px; }

  .font-item {
    padding: 10px 12px; border-radius: 10px; cursor: pointer;
    margin-bottom: 4px; transition: all 0.15s; border: 2px solid transparent;
  }
  .font-item:hover { background: #faf6f1; }
  .font-item.selected { background: #fff; border-color: #e85d75; }
  .font-item-name { font-size: 13px; font-weight: 600; }
  .font-item-meta { font-size: 11px; color: #8a7a6a; margin-top: 2px; }

  /* ── Main ── */
  .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

  .toolbar {
    padding: 12px 20px; background: #ffffff; border-bottom: 1px solid #e8d5c4;
    display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
  }
  .toolbar label { font-size: 11px; font-weight: 600; color: #7a6a5a; text-transform: uppercase; letter-spacing: 0.5px; }
  .toolbar input[type="text"] {
    background: #faf6f1; border: 1px solid #e8d5c4; color: #5a4a3a;
    padding: 6px 12px; border-radius: 6px; font-size: 13px; font-family: inherit; width: 220px;
  }
  .toolbar input[type="text"]:focus { outline: none; border-color: #e85d75; box-shadow: 0 0 0 3px rgba(232,93,117,0.12); }
  .toolbar input[type="range"] { width: 80px; accent-color: #e85d75; }
  .toolbar input[type="color"] { width: 32px; height: 28px; border: 2px solid #e8d5c4; border-radius: 6px; cursor: pointer; padding: 1px; }

  .action-btn {
    padding: 6px 16px; border: none; color: #fff; border-radius: 8px;
    font-size: 12px; font-weight: 600; cursor: pointer; font-family: inherit;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15); transition: all 0.2s;
  }
  .action-btn:hover { transform: translateY(-1px); }
  .action-btn.pink { background: linear-gradient(135deg, #e85d75, #d64560); }
  .action-btn.green { background: linear-gradient(135deg, #48bb78, #38a169); }

  .content { flex: 1; overflow-y: auto; padding: 20px; }
  .content::-webkit-scrollbar { width: 8px; }
  .content::-webkit-scrollbar-thumb { background: #e8d5c4; border-radius: 4px; }

  /* ── Drop zone ── */
  .drop-zone {
    border: 3px dashed #e8d5c4; border-radius: 20px; padding: 60px 40px;
    text-align: center; transition: all 0.3s; cursor: pointer;
    margin: 40px auto; max-width: 600px;
  }
  .drop-zone.drag-over { border-color: #e85d75; background: rgba(232,93,117,0.05); transform: scale(1.02); }
  .drop-zone h3 { font-size: 20px; margin-bottom: 8px; }
  .drop-zone p { font-size: 14px; color: #8a7a6a; margin-bottom: 8px; }
  .drop-zone .icon { font-size: 48px; margin-bottom: 16px; display: block; }
  .drop-zone .formats { font-size: 12px; color: #b0a090; margin-top: 8px; }

  /* ── Cards ── */
  .overview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(420px, 1fr)); gap: 16px; }

  .font-card {
    background: #ffffff; border: 1px solid #e8d5c4; border-radius: 12px;
    padding: 16px; cursor: pointer; transition: all 0.2s;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
  }
  .font-card:hover { border-color: #e85d75; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(232,93,117,0.15); }
  .font-card-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px; }
  .font-card-title { font-size: 16px; font-weight: 700; }
  .font-card-id { font-size: 11px; color: #e85d75; font-family: monospace; background: rgba(232,93,117,0.08); padding: 2px 8px; border-radius: 4px; }
  .font-card-stats { font-size: 11px; color: #8a7a6a; margin-bottom: 8px; }
  .font-card-stats span { margin-right: 10px; }
  .stat-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; }
  .stat-badge.blue { background: #eff6ff; color: #2563eb; }
  .stat-badge.green { background: #f0fdf4; color: #16a34a; }
  .stat-badge.purple { background: #faf5ff; color: #9333ea; }
  .stat-badge.orange { background: #fff7ed; color: #ea580c; }
  .font-card-canvas { background: #fff; border: 1px solid #f5ede5; border-radius: 8px; padding: 8px; display: flex; justify-content: center; image-rendering: pixelated; overflow: hidden; }
  .font-card-canvas canvas { image-rendering: pixelated; }

  /* ── Detail ── */
  .detail-view { display: none; }
  .detail-back { display: inline-flex; align-items: center; gap: 6px; color: #e85d75; cursor: pointer; font-size: 13px; font-weight: 500; font-family: inherit; margin-bottom: 16px; padding: 6px 12px; border-radius: 6px; background: rgba(232,93,117,0.08); border: none; }
  .detail-back:hover { background: rgba(232,93,117,0.15); }
  .detail-header h2 { font-size: 24px; font-weight: 700; margin-bottom: 4px; }
  .detail-info { display: flex; gap: 20px; flex-wrap: wrap; font-size: 13px; color: #8a7a6a; margin-bottom: 16px; }
  .detail-info strong { color: #e85d75; font-weight: 600; }
  .detail-sample { background: #fff; border: 1px solid #e8d5c4; border-radius: 8px; padding: 16px; margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; gap: 6px; image-rendering: pixelated; }
  .detail-sample canvas { image-rendering: pixelated; }
  .detail-section h3 { font-size: 11px; font-weight: 600; color: #7a6a5a; text-transform: uppercase; letter-spacing: 0.8px; margin-bottom: 12px; padding-bottom: 6px; border-bottom: 1px solid #e8d5c4; }
  .glyph-grid { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 24px; justify-content: center; }
  .glyph-cell { background: #fff; border: 1px solid #e8d5c4; border-radius: 8px; padding: 8px; text-align: center; transition: all 0.15s; display: inline-flex; flex-direction: column; align-items: center; }
  .glyph-cell:hover { border-color: #e85d75; box-shadow: 0 2px 8px rgba(232,93,117,0.1); }
  .glyph-char { font-size: 16px; font-weight: 700; margin-bottom: 2px; }
  .glyph-canvas { background: #fff; border: 1px solid #f5ede5; border-radius: 4px; padding: 2px; margin: 4px auto; display: flex; justify-content: center; image-rendering: pixelated; overflow: hidden; }
  .glyph-canvas canvas { image-rendering: pixelated; }
  .glyph-meta { font-size: 10px; font-family: monospace; color: #b0a090; }

  .dl-btn { margin-top: 8px; padding: 4px 12px; background: #fff; border: 1px solid #e8d5c4; border-radius: 6px; font-size: 11px; font-weight: 500; cursor: pointer; font-family: inherit; color: #5a4a3a; }
  .dl-btn:hover { border-color: #e85d75; color: #e85d75; }

  /* ── Convert modal ── */
  .modal-backdrop {
    position: fixed; inset: 0; background: rgba(0,0,0,0.4); z-index: 1000;
    display: none; align-items: center; justify-content: center;
  }
  .modal-backdrop.open { display: flex; }
  .modal {
    background: #fff; border-radius: 16px; padding: 28px 32px; width: 420px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.25); max-height: 80vh; overflow-y: auto;
  }
  .modal h3 { font-size: 18px; font-weight: 700; margin-bottom: 4px; }
  .modal .subtitle { font-size: 13px; color: #8a7a6a; margin-bottom: 20px; }
  .modal label { font-size: 12px; font-weight: 600; color: #7a6a5a; display: block; margin-bottom: 4px; margin-top: 12px; }
  .modal input, .modal select {
    width: 100%; padding: 8px 12px; border: 1px solid #e8d5c4; border-radius: 8px;
    font-size: 14px; font-family: inherit; color: #5a4a3a; background: #faf6f1;
  }
  .modal input:focus, .modal select:focus { outline: none; border-color: #e85d75; }
  .modal .btn-row { display: flex; gap: 10px; margin-top: 20px; justify-content: flex-end; }
  .modal .btn-row button {
    padding: 8px 20px; border-radius: 8px; font-size: 13px; font-weight: 600;
    cursor: pointer; font-family: inherit; border: 1px solid #e8d5c4; transition: all 0.2s;
  }
  .modal .btn-cancel { background: #fff; color: #5a4a3a; }
  .modal .btn-cancel:hover { border-color: #dc2626; color: #dc2626; }
  .modal .btn-convert { background: linear-gradient(135deg, #e85d75, #d64560); color: #fff; border: none; }
  .modal .btn-convert:hover { box-shadow: 0 4px 12px rgba(232,93,117,0.4); }
  .modal .btn-convert:disabled { opacity: 0.5; cursor: not-allowed; }
  .modal .progress { font-size: 12px; color: #8a7a6a; margin-top: 12px; }

  /* ── Export bar ── */
  .export-bar { padding: 8px 16px; background: #faf6f1; border-top: 1px solid #e8d5c4; display: flex; gap: 8px; align-items: center; font-size: 12px; }
  .export-bar button { padding: 5px 12px; background: #fff; border: 1px solid #e8d5c4; color: #5a4a3a; border-radius: 6px; font-size: 11px; font-weight: 500; cursor: pointer; font-family: inherit; }
  .export-bar button:hover { border-color: #e85d75; color: #e85d75; }

  /* ── Editor ── */
  .editor-view { display: none; }
  .editor-topbar {
    display: flex; align-items: center; gap: 12px; flex-wrap: wrap;
    padding: 10px 16px; background: #fff; border-bottom: 1px solid #e8d5c4;
    position: sticky; top: 0; z-index: 10;
  }
  .editor-topbar .back-btn {
    display: inline-flex; align-items: center; gap: 4px; color: #e85d75;
    cursor: pointer; font-size: 13px; font-weight: 500; font-family: inherit;
    padding: 5px 10px; border-radius: 6px; background: rgba(232,93,117,0.08);
    border: none; white-space: nowrap;
  }
  .editor-topbar .back-btn:hover { background: rgba(232,93,117,0.15); }
  .editor-char-display {
    font-size: 28px; font-weight: 700; color: #5a4a3a; line-height: 1;
    min-width: 36px; text-align: center;
  }
  .editor-font-info { font-size: 12px; color: #8a7a6a; white-space: nowrap; }
  .editor-tool-group { display: flex; gap: 4px; }
  .editor-tool-btn {
    padding: 5px 12px; border: 1px solid #e8d5c4; background: #fff;
    color: #5a4a3a; border-radius: 6px; font-size: 12px; font-weight: 500;
    cursor: pointer; font-family: inherit; transition: all 0.15s; white-space: nowrap;
  }
  .editor-tool-btn:hover { border-color: #e85d75; color: #e85d75; }
  .editor-tool-btn.active {
    background: linear-gradient(135deg, #e85d75, #d64560);
    border-color: #e85d75; color: #fff;
    box-shadow: 0 2px 8px rgba(232,93,117,0.3);
  }
  .editor-tool-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .editor-nav-btn {
    padding: 5px 10px; border: 1px solid #e8d5c4; background: #fff;
    color: #5a4a3a; border-radius: 6px; font-size: 14px; cursor: pointer;
    font-family: inherit; transition: all 0.15s;
  }
  .editor-nav-btn:hover { border-color: #e85d75; color: #e85d75; }
  .editor-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
  .editor-body {
    display: flex; gap: 20px; padding: 16px;
    align-items: flex-start; min-height: 0;
  }
  .editor-canvas-wrap {
    flex: 1; overflow: auto; background: #fff; border: 1px solid #e8d5c4;
    border-radius: 10px; padding: 12px; display: flex; flex-direction: column;
    align-items: center; gap: 8px;
  }
  .editor-canvas-wrap canvas {
    image-rendering: pixelated; cursor: crosshair;
  }
  .editor-dim-controls {
    display: flex; gap: 4px; flex-wrap: wrap; justify-content: center;
  }
  .editor-dim-btn {
    padding: 3px 8px; border: 1px solid #e8d5c4; background: #faf6f1;
    color: #8a7a6a; border-radius: 4px; font-size: 10px; font-weight: 600;
    cursor: pointer; font-family: inherit; transition: all 0.15s; white-space: nowrap;
  }
  .editor-dim-btn:hover { border-color: #e85d75; color: #e85d75; }
  .editor-side {
    width: 240px; min-width: 240px; display: flex;
    flex-direction: column; gap: 12px;
  }
  .editor-side-panel {
    background: #fff; border: 1px solid #e8d5c4; border-radius: 10px; padding: 12px;
  }
  .editor-side-panel h4 {
    font-size: 11px; font-weight: 600; color: #7a6a5a;
    text-transform: uppercase; letter-spacing: 0.5px;
    margin-bottom: 8px; padding-bottom: 4px; border-bottom: 1px solid #e8d5c4;
  }
  .editor-preview-canvas { display: flex; justify-content: center; image-rendering: pixelated; }
  .editor-preview-canvas canvas { image-rendering: pixelated; }
  .editor-glyph-info { font-size: 12px; color: #8a7a6a; }
  .editor-glyph-info span { display: block; margin-bottom: 2px; }
  .editor-save-status {
    font-size: 11px; color: #8a7a6a; margin-left: auto; white-space: nowrap;
  }
  .editor-save-status.saved { color: #16a34a; }
  .editor-save-status.saving { color: #e85d75; }

  /* ── Toast ── */
  .toast { position: fixed; bottom: 20px; right: 20px; background: #2d3748; color: #fff; padding: 10px 20px; border-radius: 12px; font-size: 14px; font-weight: 500; opacity: 0; transform: translateY(10px); transition: all 0.3s; pointer-events: none; z-index: 9999; }
  .toast.show { opacity: 1; transform: translateY(0); }
</style>
</head>
<body>

<div class="sidebar">
  <div class="sidebar-header" id="sidebarHeader">
    <h1><span class="accent">&#10006;</span> ttf2stitch Inspector</h1>
    <p id="sidebarStatus">Drop TTF/OTF or JSON files</p>
  </div>
  <div class="filter-bar">
    <button class="filter-btn active" data-filter="all">All</button>
    <button class="filter-btn" data-filter="serif">Serif</button>
    <button class="filter-btn" data-filter="sans-serif">Sans</button>
    <button class="filter-btn" data-filter="script">Script</button>
    <button class="filter-btn" data-filter="pixel">Pixel</button>
    <button class="filter-btn" data-filter="decorative">Deco</button>
  </div>
  <div class="search-bar">
    <input type="text" class="search-input" id="fontSearch" placeholder="Search fonts..." />
  </div>
  <div class="font-list" id="fontList">
    <div style="padding:20px;text-align:center;color:#b0a090">No fonts loaded yet</div>
  </div>
</div>

<div class="main">
  <div class="toolbar">
    <div>
      <label>Preview text</label><br>
      <input type="text" id="previewText" value="ABCDabcd 0123 !@#" />
    </div>
    <div>
      <label>Scale: <span id="scaleLabel">6</span>x</label><br>
      <input type="range" id="scaleSlider" min="2" max="14" value="6" />
    </div>
    <div>
      <label>Color</label><br>
      <input type="color" id="colorPicker" value="#5a4a3a" />
    </div>
    <label class="action-btn pink" style="cursor:pointer">
      Load files
      <input type="file" id="fileInput" multiple accept=".json,.ttf,.otf,.woff,.woff2" style="display:none" />
    </label>
  </div>

  <div class="content" id="mainContent">
    <div id="overviewView">
      <div class="drop-zone" id="dropZone">
        <span class="icon">&#128462;</span>
        <h3>Drop font files here</h3>
        <p>TTF, OTF, WOFF — converts automatically to bitmap</p>
        <p>JSON — loads directly as bitmap font</p>
        <div class="formats">.ttf .otf .woff .woff2 .json</div>
      </div>
      <div class="overview-grid" id="overviewGrid"></div>
    </div>
    <div id="detailView" class="detail-view"></div>
    <div id="editorView" class="editor-view"></div>
  </div>

  <div class="export-bar" id="exportBar" style="display:none">
    <span id="fontCount">0 fonts</span>
    <button id="exportAllBtn">Export all JSON</button>
    <button id="copyIdsBtn">Copy IDs</button>
  </div>
</div>

<!-- Convert TTF modal -->
<div class="modal-backdrop" id="convertModal">
  <div class="modal" style="width:480px">
    <h3 id="modalTitle" style="font-size:20px">Choose a style</h3>
    <div class="subtitle" id="modalSubtitle" style="margin-bottom:16px">filename.ttf</div>

    <!-- Presets: big friendly buttons -->
    <div id="presetGrid" style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-bottom:16px">
      <button class="preset-btn selected" data-preset="elegant" style="
        padding:16px 8px;border:2px solid #e85d75;background:#fff;border-radius:12px;
        cursor:pointer;font-family:inherit;transition:all 0.2s;text-align:center;
      ">
        <div style="font-size:24px;margin-bottom:6px">&#9998;</div>
        <div style="font-size:13px;font-weight:700;color:#5a4a3a">Elegant</div>
        <div style="font-size:10px;color:#8a7a6a;margin-top:4px">Script &amp; decorative fonts<br>Thick, connected strokes</div>
      </button>
      <button class="preset-btn" data-preset="clean" style="
        padding:16px 8px;border:2px solid #e8d5c4;background:#fff;border-radius:12px;
        cursor:pointer;font-family:inherit;transition:all 0.2s;text-align:center;
      ">
        <div style="font-size:24px;margin-bottom:6px">&#65;;</div>
        <div style="font-size:13px;font-weight:700;color:#5a4a3a">Clean</div>
        <div style="font-size:10px;color:#8a7a6a;margin-top:4px">Simple, readable fonts<br>Sharp &amp; precise</div>
      </button>
      <button class="preset-btn" data-preset="bold" style="
        padding:16px 8px;border:2px solid #e8d5c4;background:#fff;border-radius:12px;
        cursor:pointer;font-family:inherit;transition:all 0.2s;text-align:center;
      ">
        <div style="font-size:24px;margin-bottom:6px;font-weight:900">B</div>
        <div style="font-size:13px;font-weight:700;color:#5a4a3a">Bold</div>
        <div style="font-size:10px;color:#8a7a6a;margin-top:4px">Extra thick letters<br>Easy to see &amp; stitch</div>
      </button>
    </div>

    <!-- Fabric + Physical size -->
    <div style="margin-bottom:14px">
      <label style="font-size:12px;font-weight:600;color:#7a6a5a;display:block;margin-bottom:6px">Fabric type</label>
      <div id="aidaButtons" style="display:flex;gap:6px;flex-wrap:wrap">
        <button class="aida-btn" data-count="11" style="padding:6px 14px;border:2px solid #e8d5c4;background:#fff;border-radius:8px;cursor:pointer;font-family:inherit;font-size:12px;font-weight:600;color:#5a4a3a;transition:all 0.15s">Aida 11</button>
        <button class="aida-btn selected" data-count="14" style="padding:6px 14px;border:2px solid #e85d75;background:rgba(232,93,117,0.05);border-radius:8px;cursor:pointer;font-family:inherit;font-size:12px;font-weight:700;color:#e85d75;transition:all 0.15s">Aida 14</button>
        <button class="aida-btn" data-count="16" style="padding:6px 14px;border:2px solid #e8d5c4;background:#fff;border-radius:8px;cursor:pointer;font-family:inherit;font-size:12px;font-weight:600;color:#5a4a3a;transition:all 0.15s">Aida 16</button>
        <button class="aida-btn" data-count="18" style="padding:6px 14px;border:2px solid #e8d5c4;background:#fff;border-radius:8px;cursor:pointer;font-family:inherit;font-size:12px;font-weight:600;color:#5a4a3a;transition:all 0.15s">Aida 18</button>
      </div>
    </div>

    <div style="margin-bottom:14px">
      <label style="font-size:12px;font-weight:600;color:#7a6a5a;display:block;margin-bottom:6px">Letter height</label>
      <div style="display:flex;gap:8px;align-items:center">
        <input type="number" id="modalPhysicalSize" value="2" min="0.5" max="10" step="0.5" style="width:80px;padding:7px 10px;border:1px solid #e8d5c4;border-radius:8px;font-size:15px;font-weight:600;font-family:inherit;color:#5a4a3a;background:#faf6f1;text-align:center" />
        <div style="display:flex;border:1px solid #e8d5c4;border-radius:8px;overflow:hidden">
          <button id="unitCm" class="unit-btn" style="padding:7px 14px;border:none;font-size:12px;font-weight:600;cursor:pointer;font-family:inherit;background:linear-gradient(135deg,#e85d75,#d64560);color:#fff;transition:all 0.15s">cm</button>
          <button id="unitIn" class="unit-btn" style="padding:7px 14px;border:none;border-left:1px solid #e8d5c4;font-size:12px;font-weight:600;cursor:pointer;font-family:inherit;background:#fff;color:#5a4a3a;transition:all 0.15s">inch</button>
        </div>
        <div style="font-size:13px;color:#5a4a3a;margin-left:4px">
          = <strong id="stitchResult" style="color:#e85d75;font-size:16px">11</strong> stitches
        </div>
      </div>
      <div style="font-size:11px;color:#b0a090;margin-top:6px" id="sizeHint">
        On Aida 14: 2 cm ≈ 1.8 cm real (11 stitches × 1.81 mm each)
      </div>
    </div>

    <!-- Hidden field for the computed height -->
    <input type="hidden" id="modalHeight" value="11" />

    <!-- Advanced (collapsed) -->
    <details style="margin-top:8px;margin-bottom:8px">
      <summary style="cursor:pointer;font-size:12px;color:#8a7a6a;font-weight:600;padding:6px 0;user-select:none">
        Advanced options ▾
      </summary>
      <div style="padding:8px 0;display:flex;flex-direction:column;gap:8px">
        <div>
          <label style="font-size:11px;font-weight:600;color:#7a6a5a;display:block;margin-bottom:3px">Stroke thickness</label>
          <input type="number" id="modalBold" value="1" min="0" max="3" style="width:100%;padding:6px 10px;border:1px solid #e8d5c4;border-radius:6px;font-size:13px;background:#faf6f1" />
        </div>
        <div>
          <label style="font-size:11px;font-weight:600;color:#7a6a5a;display:block;margin-bottom:3px">Threshold</label>
          <div style="display:flex;gap:6px;align-items:center">
            <input type="number" id="modalThreshold" value="128" min="1" max="254" style="flex:1;padding:6px 10px;border:1px solid #e8d5c4;border-radius:6px;font-size:13px;background:#faf6f1" />
            <label style="display:flex;align-items:center;gap:3px;cursor:pointer;white-space:nowrap;margin:0">
              <input type="checkbox" id="modalAutoThreshold" checked style="width:14px;height:14px;accent-color:#e85d75" />
              <span style="font-size:10px;color:#8a7a6a">Auto</span>
            </label>
          </div>
        </div>
        <div>
          <label style="font-size:11px;font-weight:600;color:#7a6a5a;display:block;margin-bottom:3px">Strategy</label>
          <select id="modalStrategy" style="width:100%;padding:6px 10px;border:1px solid #e8d5c4;border-radius:6px;font-size:13px;background:#faf6f1">
            <option value="max-ink">Max-ink (decorative)</option>
            <option value="average">Average (clean)</option>
          </select>
        </div>
        <div>
          <label style="font-size:11px;font-weight:600;color:#7a6a5a;display:block;margin-bottom:3px">Letter spacing</label>
          <input type="number" id="modalSpacing" value="1" min="0" max="10" style="width:100%;padding:6px 10px;border:1px solid #e8d5c4;border-radius:6px;font-size:13px;background:#faf6f1" />
        </div>
        <div>
          <label style="font-size:11px;font-weight:600;color:#7a6a5a;display:block;margin-bottom:3px">Category</label>
          <select id="modalCategory" style="width:100%;padding:6px 10px;border:1px solid #e8d5c4;border-radius:6px;font-size:13px;background:#faf6f1">
            <option value="sans-serif">Sans-Serif</option>
            <option value="serif">Serif</option>
            <option value="script" selected>Script</option>
            <option value="pixel">Pixel</option>
            <option value="decorative">Decorative</option>
            <option value="gothic">Gothic</option>
          </select>
        </div>
      </div>
    </details>

    <div class="progress" id="modalProgress"></div>
    <div class="btn-row" style="margin-top:12px">
      <button class="btn-cancel" id="modalCancelBtn">Cancel</button>
      <button class="btn-convert" id="modalConvertBtn" style="padding:10px 28px;font-size:14px">Convert ✨</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
// ── State ──
const fonts = new Map();
let currentFilter = 'all', selectedFontId = null, currentView = 'overview', searchQuery = '';
let pendingFontFile = null;

// ── Editor state ──
let editorFontId = null, editorChar = null;
let editorUndoStack = [], editorIsDrawing = false, editorLastCell = null;
let editorDrawMode = null; // '1' = drawing, '0' = erasing (set on mousedown based on first pixel)
let editorSaveTimer = null, editorSaveStatus = 'idle'; // idle | saving | saved
const EDITOR_SCALE = 30;

const CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 !\"#%&'()*+,-./:;?";

// ── DOM refs ──
const fontListEl = document.getElementById('fontList');
const overviewGrid = document.getElementById('overviewGrid');
const overviewView = document.getElementById('overviewView');
const detailView = document.getElementById('detailView');
const dropZone = document.getElementById('dropZone');
const previewText = document.getElementById('previewText');
const scaleSlider = document.getElementById('scaleSlider');
const scaleLabel = document.getElementById('scaleLabel');
const colorPicker = document.getElementById('colorPicker');
const fileInput = document.getElementById('fileInput');
const toastEl = document.getElementById('toast');
const exportBar = document.getElementById('exportBar');
const convertModal = document.getElementById('convertModal');
const editorView = document.getElementById('editorView');

// ══════════════════════════════════════════════════
//  BROWSER RASTERIZER — TTF → Bitmap JSON v2
// ══════════════════════════════════════════════════

let fontCounter = 0;

function dilateBitmap(bitmap, radius) {
  if (!bitmap.length || radius <= 0) return bitmap;
  const rows = bitmap.length, cols = bitmap[0].length;
  const grid = bitmap.map(r => [...r].map(c => c === '1'));
  const result = Array.from({length: rows}, () => Array(cols).fill(false));
  for (let y = 0; y < rows; y++)
    for (let x = 0; x < cols; x++)
      if (grid[y][x])
        for (let dy = -radius; dy <= radius; dy++)
          for (let dx = -radius; dx <= radius; dx++) {
            const ny = y+dy, nx = x+dx;
            if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) result[ny][nx] = true;
          }
  return result.map(r => r.map(c => c ? '1' : '0').join(''));
}

function otsuThreshold(imageData, w, h) {
  // Build grayscale histogram from RGBA imageData
  const hist = new Array(256).fill(0);
  for (let i = 0; i < w * h; i++) {
    const idx = i * 4;
    const gray = Math.round((imageData[idx] + imageData[idx+1] + imageData[idx+2]) / 3);
    hist[gray]++;
  }
  const total = w * h;
  let sumAll = 0;
  for (let i = 0; i < 256; i++) sumAll += i * hist[i];
  let sumBg = 0, wBg = 0, maxVar = 0, best = 128;
  for (let t = 0; t < 256; t++) {
    wBg += hist[t];
    if (wBg === 0) continue;
    const wFg = total - wBg;
    if (wFg === 0) break;
    sumBg += t * hist[t];
    const meanBg = sumBg / wBg;
    const meanFg = (sumAll - sumBg) / wFg;
    const variance = wBg * wFg * (meanBg - meanFg) ** 2;
    if (variance > maxVar) { maxVar = variance; best = t; }
  }
  return best;
}

async function rasterizeTTF(arrayBuffer, filename, opts) {
  const { height, threshold, spacing, category, bold = 0, autoThreshold = false, strategy = 'average' } = opts;
  const familyName = `__ttf2stitch_${++fontCounter}__`;

  // Load font into browser
  const face = new FontFace(familyName, arrayBuffer);
  await face.load();
  document.fonts.add(face);

  // We render at a large size (height * 20) then scale down for anti-alias quality
  const renderSize = height * 20;
  const glyphs = {};
  let maxH = 0;
  const progress = document.getElementById('modalProgress');

  for (let i = 0; i < CHARSET.length; i++) {
    const char = CHARSET[i];
    if (i % 10 === 0) {
      progress.textContent = `Converting ${i}/${CHARSET.length}...`;
      await new Promise(r => setTimeout(r, 0)); // yield to UI
    }

    if (char === ' ') {
      const sw = Math.max(1, Math.round(height * 0.4));
      glyphs[char] = { width: sw, bitmap: Array(height).fill('0'.repeat(sw)) };
      continue;
    }

    // Render character at large size
    const canvas = document.createElement('canvas');
    canvas.width = renderSize * 3;
    canvas.height = renderSize * 3;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#000000';
    ctx.textBaseline = 'top';
    ctx.font = `${renderSize}px "${familyName}"`;
    ctx.fillText(char, renderSize, renderSize);

    // Get text metrics for precise bbox
    const metrics = ctx.measureText(char);
    const left = Math.floor(renderSize + (metrics.actualBoundingBoxLeft ? -metrics.actualBoundingBoxLeft : 0));
    const top2 = Math.floor(renderSize + (metrics.actualBoundingBoxAscent ? -metrics.actualBoundingBoxAscent : 0));
    const right = Math.ceil(renderSize + (metrics.actualBoundingBoxRight || metrics.width || renderSize));
    const bottom = Math.ceil(renderSize + (metrics.actualBoundingBoxDescent || renderSize));

    const cw = right - left;
    const ch = bottom - top2;
    if (cw <= 0 || ch <= 0) continue;

    // Extract content region
    const contentData = ctx.getImageData(left, top2, cw, ch);

    const targetW = Math.max(1, Math.round(cw * height / ch));
    let bitmap = [];

    if (strategy === 'max-ink') {
      // Max-ink: divide high-res into cells, mark '1' if darkest pixel has ink
      const effTh = autoThreshold ? 200 : threshold;
      const cellH = ch / height, cellW = cw / targetW;
      for (let row = 0; row < height; row++) {
        let rowStr = '';
        for (let col = 0; col < targetW; col++) {
          const y1 = Math.floor(row * cellH), y2 = Math.min(Math.floor((row+1) * cellH), ch);
          const x1 = Math.floor(col * cellW), x2 = Math.min(Math.floor((col+1) * cellW), cw);
          let minVal = 255;
          for (let py = y1; py < y2 && minVal > 0; py++)
            for (let px = x1; px < x2 && minVal > 0; px++) {
              const idx = (py * cw + px) * 4;
              const gray = (contentData.data[idx]+contentData.data[idx+1]+contentData.data[idx+2])/3;
              if (gray < minVal) minVal = gray;
            }
          rowStr += minVal < effTh ? '1' : '0';
        }
        bitmap.push(rowStr);
      }
    } else {
      // Average: LANCZOS-style resize then threshold
      const scaledCanvas = document.createElement('canvas');
      scaledCanvas.width = targetW; scaledCanvas.height = height;
      const sctx = scaledCanvas.getContext('2d', { willReadFrequently: true });
      const tmpCanvas = document.createElement('canvas');
      tmpCanvas.width = cw; tmpCanvas.height = ch;
      tmpCanvas.getContext('2d').putImageData(contentData, 0, 0);
      sctx.imageSmoothingEnabled = true;
      sctx.imageSmoothingQuality = 'high';
      sctx.drawImage(tmpCanvas, 0, 0, targetW, height);
      const scaled = sctx.getImageData(0, 0, targetW, height);
      const effTh = autoThreshold ? otsuThreshold(scaled.data, targetW, height) : threshold;
      for (let y = 0; y < height; y++) {
        let rowStr = '';
        for (let x = 0; x < targetW; x++) {
          const idx = (y * targetW + x) * 4;
          const gray = (scaled.data[idx]+scaled.data[idx+1]+scaled.data[idx+2])/3;
          rowStr += gray < effTh ? '1' : '0';
        }
        bitmap.push(rowStr);
      }
    }

    // Morphological dilation for bold effect
    if (bold > 0) bitmap = dilateBitmap(bitmap, bold);

    // Trim empty borders
    const trimmed = trimBitmap(bitmap);
    if (trimmed.length === 0 || trimmed[0].length === 0) continue;

    glyphs[char] = { width: trimmed[0].length, bitmap: trimmed };
    maxH = Math.max(maxH, trimmed.length);
  }

  progress.textContent = '';

  // Remove font
  document.fonts.delete(face);

  // Build JSON v2
  const slug = filename.replace(/\.(ttf|otf|woff2?)$/i, '')
    .toLowerCase().replace(/[\s_]+/g, '-').replace(/[^a-z0-9-]/g, '').replace(/-{2,}/g, '-').replace(/^-|-$/g, '');

  return {
    version: 2,
    id: slug,
    name: filename.replace(/\.(ttf|otf|woff2?)$/i, ''),
    height: maxH || height,
    letterSpacing: spacing,
    spaceWidth: Math.max(1, Math.round(height * 0.4)),
    source: '',
    license: '',
    charset: 'basic',
    category: category,
    tags: ['rasterized'],
    glyphs,
  };
}

function trimBitmap(bitmap) {
  let bm = [...bitmap];
  // Trim top
  while (bm.length > 0 && !/1/.test(bm[0])) bm.shift();
  // Trim bottom
  while (bm.length > 0 && !/1/.test(bm[bm.length-1])) bm.pop();
  if (bm.length === 0) return [];
  // Trim left
  const w = bm[0].length;
  let left = 0;
  for (let c = 0; c < w; c++) { if (bm.every(r => r[c] === '0')) left++; else break; }
  let right = 0;
  for (let c = w-1; c >= left; c--) { if (bm.every(r => r[c] === '0')) right++; else break; }
  if (left > 0 || right > 0) bm = bm.map(r => r.slice(left, w - right));
  return bm;
}

// ══════════════════════════════════════════════════
//  FILE PROCESSING
// ══════════════════════════════════════════════════

function isFontFile(name) {
  return /\.(ttf|otf|woff2?)$/i.test(name);
}

function processFiles(files) {
  const fontFiles = [];
  const jsonFiles = [];
  for (const f of files) {
    if (isFontFile(f.name)) fontFiles.push(f);
    else if (f.name.endsWith('.json')) jsonFiles.push(f);
  }

  // Load JSONs directly
  if (jsonFiles.length > 0) {
    Promise.all(jsonFiles.map(f => f.text().then(t => {
      try { loadFontData(JSON.parse(t), f.name); } catch {}
    }))).then(() => { if (jsonFiles.length > 0) { refreshUI(); showToast(`Loaded ${jsonFiles.length} JSON(s)`); } });
  }

  // Queue font files for conversion
  if (fontFiles.length === 1) {
    openConvertModal(fontFiles[0]);
  } else if (fontFiles.length > 1) {
    batchConvert(fontFiles);
  }
}

async function batchConvert(files) {
  const height = 12;
  showToast(`Converting ${files.length} fonts at ${height}px with auto-threshold + bold...`);
  for (const file of files) {
    const buf = await file.arrayBuffer();
    try {
      const data = await rasterizeTTF(buf, file.name, {
        height, threshold: 128, spacing: 1, category: 'sans-serif',
        bold: 1, autoThreshold: true, strategy: 'max-ink',
      });
      loadFontData(data, file.name);
    } catch (e) {
      console.warn('Failed to convert', file.name, e);
    }
  }
  refreshUI();
  showToast(`Converted ${files.length} font(s)`);
}

// ── Preset definitions ──
const PRESETS = {
  elegant: { bold: 1, autoThreshold: true, strategy: 'max-ink', spacing: 0, category: 'script' },
  clean:   { bold: 0, autoThreshold: false, strategy: 'average', spacing: 1, category: 'sans-serif' },
  bold:    { bold: 2, autoThreshold: true, strategy: 'max-ink', spacing: 1, category: 'decorative' },
};
let currentPreset = 'elegant';
let aidaCount = 14;     // stitches per inch
let sizeUnit = 'cm';    // 'cm' or 'in'

function applyPreset(name) {
  currentPreset = name;
  const p = PRESETS[name];
  document.getElementById('modalBold').value = p.bold;
  document.getElementById('modalAutoThreshold').checked = p.autoThreshold;
  document.getElementById('modalStrategy').value = p.strategy;
  document.getElementById('modalSpacing').value = p.spacing;
  document.getElementById('modalCategory').value = p.category;
  document.querySelectorAll('.preset-btn').forEach(btn => {
    const isActive = btn.dataset.preset === name;
    btn.style.borderColor = isActive ? '#e85d75' : '#e8d5c4';
    btn.style.background = isActive ? 'rgba(232,93,117,0.05)' : '#fff';
    btn.classList.toggle('selected', isActive);
  });
}

function selectAida(count) {
  aidaCount = count;
  document.querySelectorAll('.aida-btn').forEach(btn => {
    const isActive = parseInt(btn.dataset.count) === count;
    btn.style.borderColor = isActive ? '#e85d75' : '#e8d5c4';
    btn.style.background = isActive ? 'rgba(232,93,117,0.05)' : '#fff';
    btn.style.color = isActive ? '#e85d75' : '#5a4a3a';
    btn.style.fontWeight = isActive ? '700' : '600';
  });
  recalcStitches();
}

function selectUnit(unit) {
  sizeUnit = unit;
  const cmBtn = document.getElementById('unitCm');
  const inBtn = document.getElementById('unitIn');
  if (unit === 'cm') {
    cmBtn.style.background = 'linear-gradient(135deg,#e85d75,#d64560)';
    cmBtn.style.color = '#fff';
    inBtn.style.background = '#fff';
    inBtn.style.color = '#5a4a3a';
  } else {
    inBtn.style.background = 'linear-gradient(135deg,#e85d75,#d64560)';
    inBtn.style.color = '#fff';
    cmBtn.style.background = '#fff';
    cmBtn.style.color = '#5a4a3a';
  }
  recalcStitches();
}

function recalcStitches() {
  const physicalSize = parseFloat(document.getElementById('modalPhysicalSize').value) || 2;
  // Convert to inches if needed, then multiply by aida count
  const sizeInInches = sizeUnit === 'cm' ? physicalSize / 2.54 : physicalSize;
  const stitches = Math.max(4, Math.round(sizeInInches * aidaCount));

  document.getElementById('modalHeight').value = stitches;
  const resultEl = document.getElementById('stitchResult');
  if (resultEl) resultEl.textContent = stitches;

  // Calculate real physical size (may differ due to rounding)
  const mmPerStitch = 25.4 / aidaCount;
  const realMm = stitches * mmPerStitch;
  const hintEl = document.getElementById('sizeHint');
  if (hintEl) {
    if (sizeUnit === 'cm') {
      hintEl.textContent = `On Aida ${aidaCount}: ${stitches} stitches = ${(realMm / 10).toFixed(1)} cm (each stitch = ${mmPerStitch.toFixed(1)} mm)`;
    } else {
      hintEl.textContent = `On Aida ${aidaCount}: ${stitches} stitches = ${(realMm / 25.4).toFixed(2)}" (each stitch = ${(1/aidaCount).toFixed(3)}")`;
    }
  }
}

function openConvertModal(file) {
  pendingFontFile = file;
  document.getElementById('modalTitle').textContent = 'Choose a style';
  document.getElementById('modalSubtitle').textContent = file.name;
  document.getElementById('modalProgress').textContent = '';
  document.getElementById('modalConvertBtn').disabled = false;
  document.getElementById('modalConvertBtn').textContent = 'Convert ✨';
  // Reset defaults
  aidaCount = 14;
  sizeUnit = 'cm';
  document.getElementById('modalPhysicalSize').value = 2;
  applyPreset('elegant');
  selectAida(14);
  selectUnit('cm');
  recalcStitches();
  convertModal.classList.add('open');
}

function closeModal() {
  convertModal.classList.remove('open');
  pendingFontFile = null;
}

// Bind modal controls (after DOM ready)
setTimeout(() => {
  document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', () => applyPreset(btn.dataset.preset));
  });
  document.querySelectorAll('.aida-btn').forEach(btn => {
    btn.addEventListener('click', () => selectAida(parseInt(btn.dataset.count)));
  });
  document.getElementById('unitCm').addEventListener('click', () => selectUnit('cm'));
  document.getElementById('unitIn').addEventListener('click', () => selectUnit('in'));
  const physInput = document.getElementById('modalPhysicalSize');
  if (physInput) physInput.addEventListener('input', recalcStitches);
}, 0);

async function doConvert() {
  if (!pendingFontFile) return;
  const btn = document.getElementById('modalConvertBtn');
  btn.disabled = true;
  btn.textContent = 'Converting...';

  const file = pendingFontFile;
  const autoTh = document.getElementById('modalAutoThreshold').checked;
  const opts = {
    height: parseInt(document.getElementById('modalHeight').value) || 12,
    threshold: parseInt(document.getElementById('modalThreshold').value) || 128,
    autoThreshold: autoTh,
    bold: parseInt(document.getElementById('modalBold').value) || 0,
    strategy: document.getElementById('modalStrategy').value,
    spacing: parseInt(document.getElementById('modalSpacing').value) || 1,
    category: document.getElementById('modalCategory').value,
  };

  try {
    const buf = await file.arrayBuffer();
    const data = await rasterizeTTF(buf, file.name, opts);
    loadFontData(data, file.name);
    closeModal();
    refreshUI();
    showToast(`Converted: ${data.name} (${Object.keys(data.glyphs).length} glyphs)`);
    // Auto-navigate to detail
    showDetail(data.id);
  } catch (e) {
    document.getElementById('modalProgress').textContent = `Error: ${e.message}`;
    console.error(e);
  }

  btn.disabled = false;
  btn.textContent = 'Convert';
}

// ══════════════════════════════════════════════════
//  LOAD / RENDER EXISTING FONTS
// ══════════════════════════════════════════════════

function loadFontData(data, filename) {
  if (!data || !data.glyphs || !data.version) return;
  const id = data.id || filename.replace(/\.(json|ttf|otf)$/i, '');
  const entry = {
    id, name: data.name || id, height: data.height || 0,
    category: data.category || 'sans-serif', charset: data.charset || 'basic',
    glyphCount: Object.keys(data.glyphs).length,
    source: data.source || '', license: data.license || '',
    letterSpacing: data.letterSpacing ?? 1, spaceWidth: data.spaceWidth ?? 3,
    tags: data.tags || [],
  };
  fonts.set(id, { entry, data });
}

// ── Bitmap rendering (same as before) ──
function hexToRgb(hex) { return { r: parseInt(hex.slice(1,3),16), g: parseInt(hex.slice(3,5),16), b: parseInt(hex.slice(5,7),16) }; }
function getEffectiveBitmap(glyph) {
  if (!glyph.bitmap || !glyph.bitmap.length) return [];
  let last = -1;
  for (let i = 0; i < glyph.bitmap.length; i++) { if (/1/.test(glyph.bitmap[i])) last = i; }
  return last >= 0 ? glyph.bitmap.slice(0, last + 1) : [];
}
function renderTextToCanvas(fontData, text, scale, color) {
  if (!fontData || !fontData.glyphs) return null;
  const G = fontData.glyphs;
  const maxH = Math.max(1, ...Object.values(G).map(g => getEffectiveBitmap(g).length));
  let totalW = 0;
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    totalW += ch === ' ' ? (fontData.spaceWidth||3) : (G[ch] ? G[ch].width : (fontData.spaceWidth||3));
    if (i < text.length-1) totalW += (fontData.letterSpacing??1);
  }
  if (totalW <= 0 || maxH <= 0) return null;
  const pw = totalW+2, ph = maxH+2, cv = document.createElement('canvas');
  cv.width = pw*scale; cv.height = ph*scale; cv.style.width = pw*scale+'px'; cv.style.height = ph*scale+'px';
  const ctx = cv.getContext('2d'); ctx.fillStyle = '#fff'; ctx.fillRect(0,0,cv.width,cv.height);
  if (scale >= 4) { ctx.strokeStyle = '#f0ebe4'; ctx.lineWidth = 0.5;
    for (let x=0;x<=pw;x++){ctx.beginPath();ctx.moveTo(x*scale,0);ctx.lineTo(x*scale,cv.height);ctx.stroke();}
    for (let y=0;y<=ph;y++){ctx.beginPath();ctx.moveTo(0,y*scale);ctx.lineTo(cv.width,y*scale);ctx.stroke();}
  }
  const rgb = hexToRgb(color); ctx.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`; const gap = scale>=4?1:0;
  let cx = 1;
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (ch===' '||!G[ch]) { cx += (ch===' '?(fontData.spaceWidth||3):(fontData.spaceWidth||3)); if(i<text.length-1) cx+=(fontData.letterSpacing??1); continue; }
    const gl = G[ch], bm = getEffectiveBitmap(gl), off = maxH-bm.length;
    for (let r=0;r<bm.length;r++) for(let c=0;c<bm[r].length;c++) if(bm[r][c]==='1') ctx.fillRect((cx+c)*scale,(1+off+r)*scale,scale-gap,scale-gap);
    cx += gl.width; if(i<text.length-1) cx+=(fontData.letterSpacing??1);
  }
  return cv;
}
function renderGlyphToCanvas(glyph, scale, color) {
  const bm = getEffectiveBitmap(glyph); if(!bm.length) return null;
  const w=glyph.width+2, h=bm.length+2, cv=document.createElement('canvas');
  cv.width=w*scale; cv.height=h*scale; cv.style.width=w*scale+'px'; cv.style.height=h*scale+'px';
  const ctx=cv.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,cv.width,cv.height);
  if(scale>=4){ctx.strokeStyle='#f0ebe4';ctx.lineWidth=0.5;for(let x=0;x<=w;x++){ctx.beginPath();ctx.moveTo(x*scale,0);ctx.lineTo(x*scale,cv.height);ctx.stroke();}for(let y=0;y<=h;y++){ctx.beginPath();ctx.moveTo(0,y*scale);ctx.lineTo(cv.width,y*scale);ctx.stroke();}}
  const rgb=hexToRgb(color); ctx.fillStyle=`rgb(${rgb.r},${rgb.g},${rgb.b})`; const gap=scale>=4?1:0;
  for(let r=0;r<bm.length;r++) for(let c=0;c<bm[r].length;c++) if(bm[r][c]==='1') ctx.fillRect((1+c)*scale,(1+r)*scale,scale-gap,scale-gap);
  return cv;
}

// ══════════════════════════════════════════════════
//  UI
// ══════════════════════════════════════════════════

function escapeHtml(s) { const d=document.createElement('div'); d.textContent=s; return d.innerHTML; }

function getFilteredFonts() {
  return [...fonts.values()]
    .filter(({entry}) => {
      if (currentFilter!=='all' && entry.category!==currentFilter) return false;
      if (searchQuery) { const q=searchQuery.toLowerCase(); return entry.name.toLowerCase().includes(q)||entry.id.toLowerCase().includes(q); }
      return true;
    })
    .sort((a,b) => a.entry.height-b.entry.height || a.entry.name.localeCompare(b.entry.name));
}

function refreshUI() {
  const count = fonts.size;
  document.getElementById('sidebarStatus').textContent = count+' font'+(count!==1?'s':'')+' loaded';
  exportBar.style.display = count>0?'flex':'none';
  document.getElementById('fontCount').textContent = count+' fonts';
  dropZone.style.display = count>0?'none':'block';
  renderSidebar();
  if (currentView==='overview') renderOverview();
}

function renderSidebar() {
  const filtered = getFilteredFonts(); fontListEl.innerHTML = '';
  if (!filtered.length && fonts.size>0) { fontListEl.innerHTML='<div style="padding:20px;text-align:center;color:#b0a090">No matches</div>'; return; }
  for (const {entry} of filtered) {
    const div = document.createElement('div');
    div.className = 'font-item'+(selectedFontId===entry.id?' selected':'');
    div.innerHTML = `<div class="font-item-name">${escapeHtml(entry.name)}</div><div class="font-item-meta">${escapeHtml(String(entry.height))}px &middot; ${escapeHtml(entry.category)} &middot; ${escapeHtml(String(entry.glyphCount))} glyphs</div>`;
    div.addEventListener('click', () => showDetail(entry.id));
    fontListEl.appendChild(div);
  }
}

function renderOverview() {
  overviewGrid.innerHTML = '';
  const filtered = getFilteredFonts();
  const text = previewText.value||'ABCabc 123', scale = parseInt(scaleSlider.value), color = colorPicker.value;
  for (const {entry, data} of filtered) {
    const card = document.createElement('div'); card.className = 'font-card';
    card.innerHTML = `
      <div class="font-card-header"><div class="font-card-title">${escapeHtml(entry.name)}</div><div class="font-card-id">${escapeHtml(entry.id)}</div></div>
      <div class="font-card-stats"><span class="stat-badge blue">${escapeHtml(String(entry.height))}px</span><span class="stat-badge green">${escapeHtml(String(entry.glyphCount))} glyphs</span><span class="stat-badge purple">${escapeHtml(entry.category)}</span></div>
      <div class="font-card-canvas"></div>`;
    card.addEventListener('click', () => showDetail(entry.id));
    overviewGrid.appendChild(card);
    const cc = card.querySelector('.font-card-canvas');
    const cv = renderTextToCanvas(data, text, Math.min(scale,5), color);
    if (cv) { cv.style.maxWidth='100%'; cv.style.height='auto'; cc.appendChild(cv); }
  }
}

function showDetail(fontId) {
  selectedFontId = fontId; currentView = 'detail';
  overviewView.style.display='none'; editorView.style.display='none'; detailView.style.display='block';
  const {entry, data} = fonts.get(fontId);
  const G = data.glyphs||{}, keys = Object.keys(G).sort();
  const scale = parseInt(scaleSlider.value), color = colorPicker.value, text = previewText.value||'ABCabc 123';

  detailView.innerHTML = `
    <button class="detail-back" id="detailBackBtn">&#8592; Back</button>
    <div class="detail-header">
      <h2>${escapeHtml(entry.name)}
        <button class="dl-btn" id="detailDownloadBtn">Download JSON</button>
      </h2>
      <div class="detail-info">
        <span>ID: <strong>${escapeHtml(entry.id)}</strong></span>
        <span>Height: <strong>${escapeHtml(String(entry.height))}px</strong></span>
        <span>Category: <strong>${escapeHtml(entry.category)}</strong></span>
        <span>Glyphs: <strong>${keys.length}</strong></span>
        <span>Spacing: <strong>${escapeHtml(String(entry.letterSpacing))}</strong></span>
        ${entry.source?`<span>Source: <strong>${escapeHtml(entry.source)}</strong></span>`:''}
      </div>
    </div>
    <div class="detail-section"><h3>Preview</h3><div class="detail-sample" id="ds"></div></div>
    <div class="detail-section"><h3>Full Alphabet</h3><div class="detail-sample" id="da"></div></div>
    <div class="detail-section"><h3>All Glyphs (${keys.length})</h3><div class="glyph-grid" id="gg"></div></div>`;

  document.getElementById('detailBackBtn').addEventListener('click', () => showOverview());
  document.getElementById('detailDownloadBtn').addEventListener('click', () => downloadJSON(fontId));

  const ds = document.getElementById('ds');
  const c1 = renderTextToCanvas(data, text, scale, color);
  if (c1) ds.appendChild(c1);

  const da = document.getElementById('da');
  for (const line of ['ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz','0123456789 !@#$%&*']) {
    const c = renderTextToCanvas(data, line, scale, color);
    if (c) { c.style.marginBottom='6px'; da.appendChild(c); }
  }

  const gg = document.getElementById('gg');
  // Adaptive scale: fit glyphs within a max cell size (120px canvas area)
  const MAX_CELL_PX = 120;
  for (const char of keys) {
    const gl = G[char], bm = getEffectiveBitmap(gl);
    const glyphW = gl.width + 2, glyphH = bm.length + 2;
    // Calculate scale that fits within MAX_CELL_PX
    const fitScale = Math.max(2, Math.min(scale, Math.floor(MAX_CELL_PX / Math.max(glyphW, glyphH))));

    const cell = document.createElement('div'); cell.className = 'glyph-cell';
    cell.innerHTML = `<div class="glyph-char">${escapeHtml(char===' '?'␣':char)}</div><div class="glyph-canvas"></div><div class="glyph-meta">${escapeHtml(String(gl.width))}&times;${escapeHtml(String(bm.length))}</div><button class="dl-btn" style="margin-top:4px;font-size:10px;padding:2px 8px">Edit</button>`;
    gg.appendChild(cell);
    const gc = cell.querySelector('.glyph-canvas');
    const cv = renderGlyphToCanvas(gl, fitScale, color);
    if (cv) gc.appendChild(cv);
    cell.querySelector('.dl-btn').addEventListener('click', (e) => {
      e.stopPropagation();
      openEditor(fontId, char);
    });
  }
  renderSidebar();
}

function showOverview() {
  currentView='overview'; selectedFontId=null;
  detailView.style.display='none'; editorView.style.display='none'; overviewView.style.display='block';
  renderOverview(); renderSidebar();
}

// ── Export ──
function downloadJSON(fontId) {
  const {data} = fonts.get(fontId);
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = (data.id||'font')+'.json'; a.click(); URL.revokeObjectURL(a.href);
  showToast('Downloaded!');
}
function exportAllJSON() {
  for (const [id] of fonts) downloadJSON(id);
}
function copyAllIds() {
  navigator.clipboard.writeText([...fonts.keys()].join(', ')).then(() => showToast('Copied!'));
}
function showToast(msg) { toastEl.textContent=msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'),1500); }

// ══════════════════════════════════════════════════
//  PIXEL EDITOR
// ══════════════════════════════════════════════════

function openEditor(fontId, char) {
  editorFontId = fontId;
  editorChar = char;
  editorDrawMode = null;
  editorUndoStack = [];
  editorIsDrawing = false;
  editorLastCell = null;
  editorSaveStatus = 'idle';

  currentView = 'editor';
  overviewView.style.display = 'none';
  detailView.style.display = 'none';
  editorView.style.display = 'block';

  renderEditor();
}

function renderEditor() {
  const { entry, data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  if (!glyph) return;

  const bm = glyph.bitmap;
  const rows = bm.length;
  const cols = glyph.width;
  const sortedChars = Object.keys(data.glyphs).sort();
  const charIdx = sortedChars.indexOf(editorChar);
  const hasPrev = charIdx > 0;
  const hasNext = charIdx < sortedChars.length - 1;
  const displayChar = editorChar === ' ' ? '␣' : escapeHtml(editorChar);

  editorView.innerHTML = `
    <div class="editor-topbar">
      <button class="back-btn" id="editorBack">&#8592; Back</button>
      <div class="editor-char-display">${displayChar}</div>
      <div class="editor-font-info">${escapeHtml(entry.name)} &middot; ${escapeHtml(String(cols))}&times;${escapeHtml(String(rows))}</div>
      <button class="editor-tool-btn" id="editorUndo" ${editorUndoStack.length===0?'disabled':''}>&#8630; Undo</button>
      <button class="editor-tool-btn" id="editorSave">Save</button>
      <button class="editor-tool-btn" id="editorDownload">Download JSON</button>
      <div class="editor-tool-group">
        <button class="editor-nav-btn" id="editorPrev" ${hasPrev?'':'disabled'}>&#8592;</button>
        <button class="editor-nav-btn" id="editorNext" ${hasNext?'':'disabled'}>&#8594;</button>
      </div>
      <div class="editor-save-status ${editorSaveStatus==='saved'?'saved':editorSaveStatus==='saving'?'saving':''}" id="editorSaveLabel">
        ${editorSaveStatus==='saving'?'Saving...':editorSaveStatus==='saved'?'Saved':''}
      </div>
    </div>
    <div class="editor-body">
      <div class="editor-canvas-wrap">
        <canvas id="editorCanvas" width="${(cols+2)*EDITOR_SCALE}" height="${(rows+2)*EDITOR_SCALE}"></canvas>
        <div class="editor-dim-controls">
          <button class="editor-dim-btn" id="addRowTop">+ Row top</button>
          <button class="editor-dim-btn" id="addRowBottom">+ Row bottom</button>
          <button class="editor-dim-btn" id="addColLeft">+ Col left</button>
          <button class="editor-dim-btn" id="addColRight">+ Col right</button>
          <button class="editor-dim-btn" id="rmRowTop" ${rows<=1?'disabled':''}>- Row top</button>
          <button class="editor-dim-btn" id="rmRowBottom" ${rows<=1?'disabled':''}>- Row bottom</button>
          <button class="editor-dim-btn" id="rmColLeft" ${cols<=1?'disabled':''}>- Col left</button>
          <button class="editor-dim-btn" id="rmColRight" ${cols<=1?'disabled':''}>- Col right</button>
        </div>
      </div>
      <div class="editor-side">
        <div class="editor-side-panel">
          <h4>Preview</h4>
          <div class="editor-preview-canvas" id="editorGlyphPreview"></div>
        </div>
        <div class="editor-side-panel">
          <h4>Text Preview</h4>
          <div class="editor-preview-canvas" id="editorTextPreview" style="overflow-x:auto"></div>
        </div>
        <div class="editor-side-panel">
          <h4>Glyph Info</h4>
          <div class="editor-glyph-info">
            <span>Char: <strong>${displayChar}</strong></span>
            <span>Width: <strong>${escapeHtml(String(cols))}</strong></span>
            <span>Height: <strong>${escapeHtml(String(rows))}</strong></span>
            <span>Filled: <strong>${bm.reduce((s,r) => s + [...r].filter(c=>c==='1').length, 0)}</strong> px</span>
          </div>
        </div>
      </div>
    </div>`;

  // Draw the main editor canvas
  drawEditorGrid();
  drawEditorPreviews();
  bindEditorEvents();
}

function drawEditorGrid() {
  const canvas = document.getElementById('editorCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const { data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  const bm = glyph.bitmap;
  const rows = bm.length, cols = glyph.width;
  const s = EDITOR_SCALE;
  const pad = 1; // 1-cell padding

  canvas.width = (cols + pad * 2) * s;
  canvas.height = (rows + pad * 2) * s;

  // White background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Padding area (light)
  ctx.fillStyle = '#faf6f1';
  // Top pad
  ctx.fillRect(0, 0, canvas.width, pad * s);
  // Bottom pad
  ctx.fillRect(0, (rows + pad) * s, canvas.width, pad * s);
  // Left pad
  ctx.fillRect(0, 0, pad * s, canvas.height);
  // Right pad
  ctx.fillRect((cols + pad) * s, 0, pad * s, canvas.height);

  // Filled cells
  const color = colorPicker.value;
  const rgb = hexToRgb(color);
  ctx.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (bm[r] && bm[r][c] === '1') {
        ctx.fillRect((pad + c) * s, (pad + r) * s, s, s);
      }
    }
  }

  // Grid lines
  ctx.strokeStyle = '#f0ebe4';
  ctx.lineWidth = 1;
  for (let x = 0; x <= cols + pad * 2; x++) {
    ctx.beginPath();
    ctx.moveTo(x * s + 0.5, 0);
    ctx.lineTo(x * s + 0.5, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y <= rows + pad * 2; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * s + 0.5);
    ctx.lineTo(canvas.width, y * s + 0.5);
    ctx.stroke();
  }

  // Heavier border around the editable area
  ctx.strokeStyle = '#e8d5c4';
  ctx.lineWidth = 2;
  ctx.strokeRect(pad * s, pad * s, cols * s, rows * s);
}

function drawEditorPreviews() {
  const { data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  const color = colorPicker.value;

  // Glyph preview
  const glyphPreview = document.getElementById('editorGlyphPreview');
  if (glyphPreview) {
    glyphPreview.innerHTML = '';
    const cv = renderGlyphToCanvas(glyph, 6, color);
    if (cv) glyphPreview.appendChild(cv);
  }

  // Text preview
  const textPreview = document.getElementById('editorTextPreview');
  if (textPreview) {
    textPreview.innerHTML = '';
    const cv = renderTextToCanvas(data, 'ABCabc', 4, color);
    if (cv) { cv.style.maxWidth = '100%'; cv.style.height = 'auto'; textPreview.appendChild(cv); }
  }
}

function editorCellFromMouse(e) {
  const canvas = document.getElementById('editorCanvas');
  if (!canvas) return null;
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (e.clientX - rect.left) * scaleX;
  const y = (e.clientY - rect.top) * scaleY;
  const col = Math.floor(x / EDITOR_SCALE) - 1; // subtract padding
  const row = Math.floor(y / EDITOR_SCALE) - 1;
  const { data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  if (row < 0 || row >= glyph.bitmap.length || col < 0 || col >= glyph.width) return null;
  return { row, col };
}

function editorTogglePixel(row, col) {
  const { data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  const oldValue = glyph.bitmap[row][col];
  // Use editorDrawMode: set on mousedown based on first pixel clicked
  const newValue = editorDrawMode;
  if (oldValue === newValue) return false;

  editorUndoStack.push({ row, col, oldValue });

  const oldRow = glyph.bitmap[row];
  glyph.bitmap[row] = oldRow.substring(0, col) + newValue + oldRow.substring(col + 1);

  return true;
}

function editorUndo() {
  if (editorUndoStack.length === 0) return;
  const { row, col, oldValue } = editorUndoStack.pop();
  const { data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  const oldRow = glyph.bitmap[row];
  glyph.bitmap[row] = oldRow.substring(0, col) + oldValue + oldRow.substring(col + 1);
  drawEditorGrid();
  drawEditorPreviews();
  scheduleAutoSave();
  // Update undo button
  const btn = document.getElementById('editorUndo');
  if (btn) btn.disabled = editorUndoStack.length === 0;
}

function scheduleAutoSave() {
  clearTimeout(editorSaveTimer);
  editorSaveTimer = setTimeout(() => autoSaveEditor(), 1000);
}

async function autoSaveEditor() {
  if (!editorFontId) return;
  const { data } = fonts.get(editorFontId);
  const label = document.getElementById('editorSaveLabel');
  editorSaveStatus = 'saving';
  if (label) { label.textContent = 'Saving...'; label.className = 'editor-save-status saving'; }

  try {
    const resp = await fetch('/api/save', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    if (resp.ok) {
      editorSaveStatus = 'saved';
      if (label) { label.textContent = 'Saved'; label.className = 'editor-save-status saved'; }
    }
  } catch {
    // Server not running, silently ignore
    editorSaveStatus = 'idle';
    if (label) { label.textContent = ''; label.className = 'editor-save-status'; }
  }
}

function editorHighlightCell(row, col) {
  const canvas = document.getElementById('editorCanvas');
  if (!canvas) return;
  // Redraw grid, then overlay highlight
  drawEditorGrid();
  const ctx = canvas.getContext('2d');
  const s = EDITOR_SCALE;
  ctx.fillStyle = 'rgba(232, 93, 117, 0.15)';
  ctx.fillRect((1 + col) * s, (1 + row) * s, s, s);
}

function bindEditorEvents() {
  const canvas = document.getElementById('editorCanvas');
  if (!canvas) return;

  // Mouse drawing — click toggles: if pixel is '0' → draw mode, if '1' → erase mode
  canvas.addEventListener('mousedown', (e) => {
    const cell = editorCellFromMouse(e);
    if (!cell) return;
    const { data } = fonts.get(editorFontId);
    const currentValue = data.glyphs[editorChar].bitmap[cell.row][cell.col];
    editorDrawMode = currentValue === '1' ? '0' : '1'; // toggle direction for entire drag
    editorIsDrawing = true;
    editorLastCell = `${cell.row},${cell.col}`;
    if (editorTogglePixel(cell.row, cell.col)) {
      drawEditorGrid();
      drawEditorPreviews();
      scheduleAutoSave();
      const btn = document.getElementById('editorUndo');
      if (btn) btn.disabled = false;
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const cell = editorCellFromMouse(e);
    if (!cell) return;
    const cellKey = `${cell.row},${cell.col}`;
    if (editorIsDrawing) {
      if (cellKey !== editorLastCell) {
        editorLastCell = cellKey;
        if (editorTogglePixel(cell.row, cell.col)) {
          drawEditorGrid();
          drawEditorPreviews();
          scheduleAutoSave();
          const btn = document.getElementById('editorUndo');
          if (btn) btn.disabled = false;
        }
      }
    } else {
      editorHighlightCell(cell.row, cell.col);
    }
  });

  canvas.addEventListener('mouseup', () => { editorIsDrawing = false; editorLastCell = null; });
  canvas.addEventListener('mouseleave', () => {
    editorIsDrawing = false; editorLastCell = null;
    drawEditorGrid(); // remove highlight
  });

  // Toolbar buttons
  document.getElementById('editorBack').addEventListener('click', () => {
    showDetail(editorFontId);
  });

  document.getElementById('editorUndo').addEventListener('click', () => editorUndo());

  document.getElementById('editorSave').addEventListener('click', () => {
    clearTimeout(editorSaveTimer);
    autoSaveEditor();
  });

  document.getElementById('editorDownload').addEventListener('click', () => {
    downloadJSON(editorFontId);
  });

  // Navigation
  const { data } = fonts.get(editorFontId);
  const sortedChars = Object.keys(data.glyphs).sort();
  const charIdx = sortedChars.indexOf(editorChar);

  document.getElementById('editorPrev').addEventListener('click', () => {
    if (charIdx > 0) openEditor(editorFontId, sortedChars[charIdx - 1]);
  });

  document.getElementById('editorNext').addEventListener('click', () => {
    if (charIdx < sortedChars.length - 1) openEditor(editorFontId, sortedChars[charIdx + 1]);
  });

  // Dimension controls
  document.getElementById('addRowTop').addEventListener('click', () => editorAddRow('top'));
  document.getElementById('addRowBottom').addEventListener('click', () => editorAddRow('bottom'));
  document.getElementById('addColLeft').addEventListener('click', () => editorAddCol('left'));
  document.getElementById('addColRight').addEventListener('click', () => editorAddCol('right'));
  document.getElementById('rmRowTop').addEventListener('click', () => editorRemoveRow('top'));
  document.getElementById('rmRowBottom').addEventListener('click', () => editorRemoveRow('bottom'));
  document.getElementById('rmColLeft').addEventListener('click', () => editorRemoveCol('left'));
  document.getElementById('rmColRight').addEventListener('click', () => editorRemoveCol('right'));
}

function editorAddRow(position) {
  const { entry, data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  const emptyRow = '0'.repeat(glyph.width);
  if (position === 'top') {
    glyph.bitmap.unshift(emptyRow);
  } else {
    glyph.bitmap.push(emptyRow);
  }
  editorUpdateDimensions(entry, data);
  editorUndoStack = []; // dimension changes clear undo
  renderEditor();
  scheduleAutoSave();
}

function editorRemoveRow(position) {
  const { entry, data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  if (glyph.bitmap.length <= 1) return;
  if (position === 'top') {
    glyph.bitmap.shift();
  } else {
    glyph.bitmap.pop();
  }
  editorUpdateDimensions(entry, data);
  editorUndoStack = [];
  renderEditor();
  scheduleAutoSave();
}

function editorAddCol(position) {
  const { entry, data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  if (position === 'left') {
    glyph.bitmap = glyph.bitmap.map(r => '0' + r);
  } else {
    glyph.bitmap = glyph.bitmap.map(r => r + '0');
  }
  glyph.width++;
  editorUpdateDimensions(entry, data);
  editorUndoStack = [];
  renderEditor();
  scheduleAutoSave();
}

function editorRemoveCol(position) {
  const { entry, data } = fonts.get(editorFontId);
  const glyph = data.glyphs[editorChar];
  if (glyph.width <= 1) return;
  if (position === 'left') {
    glyph.bitmap = glyph.bitmap.map(r => r.slice(1));
  } else {
    glyph.bitmap = glyph.bitmap.map(r => r.slice(0, -1));
  }
  glyph.width--;
  editorUpdateDimensions(entry, data);
  editorUndoStack = [];
  renderEditor();
  scheduleAutoSave();
}

function editorUpdateDimensions(entry, data) {
  // Recalculate font-level height = max bitmap height across all glyphs
  let maxH = 0;
  for (const g of Object.values(data.glyphs)) {
    maxH = Math.max(maxH, g.bitmap ? g.bitmap.length : 0);
  }
  data.height = maxH;
  entry.height = maxH;
  entry.glyphCount = Object.keys(data.glyphs).length;
}

// ── Events ──
document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.filter-btn').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active'); currentFilter = btn.dataset.filter;
    if (currentView==='overview') renderOverview(); renderSidebar();
  });
});
document.getElementById('fontSearch').addEventListener('input', e => {
  searchQuery = e.target.value.trim();
  if (currentView==='overview') renderOverview(); renderSidebar();
});
let renderTimeout;
function debouncedRender() {
  clearTimeout(renderTimeout);
  renderTimeout = setTimeout(() => { if(currentView==='overview') renderOverview(); else if(currentView==='editor') { drawEditorGrid(); drawEditorPreviews(); } else if(selectedFontId) showDetail(selectedFontId); }, 200);
}
previewText.addEventListener('input', debouncedRender);
scaleSlider.addEventListener('input', () => { scaleLabel.textContent=scaleSlider.value; debouncedRender(); });
colorPicker.addEventListener('input', debouncedRender);

// Inline onclick replacements
document.getElementById('sidebarHeader').addEventListener('click', showOverview);
document.getElementById('exportAllBtn').addEventListener('click', exportAllJSON);
document.getElementById('copyIdsBtn').addEventListener('click', copyAllIds);
document.getElementById('modalCancelBtn').addEventListener('click', closeModal);
document.getElementById('modalConvertBtn').addEventListener('click', doConvert);

// Drag and drop
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('drag-over'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove('drag-over'); processFiles(e.dataTransfer.files); });
dropZone.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', () => { if(fileInput.files.length>0) processFiles(fileInput.files); fileInput.value=''; });
document.body.addEventListener('dragover', e => e.preventDefault());
document.body.addEventListener('drop', e => { e.preventDefault(); processFiles(e.dataTransfer.files); });

// Auto-load from server
async function tryAutoLoad() {
  try {
    const r = await fetch('/output/_manifest.json');
    if (!r.ok) return;
    const list = await r.json();
    for (const f of list) { try { const d = await (await fetch(`/output/${f}`)).json(); loadFontData(d, f); } catch {} }
    if (fonts.size > 0) refreshUI();
  } catch {}
}
tryAutoLoad();
</script>
</body>
</html>
